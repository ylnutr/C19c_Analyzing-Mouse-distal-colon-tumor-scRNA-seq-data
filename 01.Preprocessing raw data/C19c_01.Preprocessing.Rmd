---
title: "C19c_01.Preprocessing"
author: "Yujin L"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 0. Background and Information

## 0-1. Project Backgound

* Early onset colorectal cancer (EOCRC) is increasing yet the mechanism for the accelerated shift to a younger age is unknown. We hypothesize that sporadic gene mutations that are necessary for colon carcinogenesis but not sufficient to cause cancer, create a preneoplastic cell state for increased risk of transformation.

## 0-2. Method

* To identify transitional cell phenotypes, we used Spatial Transcriptomics (ST) on distal colon samples from Car1-Cre (CAC) mice with Cre expression limited to ~6% of the distal colon/rectum epithelium, where EOCRC is more prevalent.  

**(A) Mice:** Car1-Cre (CAC) transgenic mice express Cre recombinase under the control of the mouse Car1 gene promoter (Xue, Fleet 2010 Mol Cancer Res.8:1095). This limits Cre expression to the distal colon and rectum, where EOCRC is more prevalent. CAC mice were crossed to those with floxed alleles to generate mice with one (Apc+/-, ACR) or two (Apc+/-; KrasG12D, AKCR) non-transforming, oncogene mutations. 
  
**(B) Sample information and tissue processing:** Distal colon and tumors found in the distal colon were collected from 10-wk CR, 15-20 wk ACR, or 4 wk and 8-10 wk AKCR mice. Cells were dissociated from distal colon crypts and tumors. Dissociated single cells were stained with LIVE/DEAD Fixable Dead Cell Stains and fixed overnight at 4 °C. Fixed cells were sorted on Sony MA900, collecting only unstained(live) cells, and stored at −80 °C until library preparation. Fixation and storage of cells followed the Fixation of Cells & Nuclei for Chromium Fixed RNA Profiling Demonstrated Protocol (CG000478, revision D).
  
**(C) 10X Chromium Single Cell Flex Gene Expression:** Library preparation and sequencing followed the Chromium Fixed RNA Profiling for Multiplexed Samples User Guide (CG000527, revision D).  cDNA libraries were constructed and sequenced on an Illumina NextSeq 500. Cell Ranger version 9.0.1 was used for analysis.
  
## 0-3. Set working directory

In this step, we verify and update the working directory to ensure that all subsequent file operations (e.g., reading or writing data) are performed in the correct project folder. This is particularly important for maintaining reproducibility and avoiding file path errors. The directory is set to the folder containing the results of the functional annotation analysis for spatial transcriptomics clusters.
  
```{r setwd, echo=TRUE, warning=TRUE}
getwd()
setwd("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/04.Analysis in R/01.Preprocessing without ACR_c2/")
getwd()
```
  
# 1. Load packages

* Besides Seurat, we need to import some useful packages.

* dplyr and ggplot2 are part of tidyverse, a readable and flexible R language for solving data science challenges. I personally prefer the coding style with tidyverse, but you may use base R too. patchwork combines separate ggplots into the same graphic with easy access to control layouts. limma is a Bioconductor package to analyze microarray data. It is not essential for our analysis, but may provide a more efficient implementation of the Wilcoxon rank sum test in differential expression analysis.

```{r library, echo=TRUE, warning=TRUE}
library(tidyverse)
library(Seurat)
library(dplyr) # data manipulation
library(ggplot2)
library(patchwork)
library(clustree)
library(scran)
library(viridis)
library(ggforce)
library(gghalves)
library(ggridges)
library(future)
library(BPCells)
library(SeuratData)
library(SeuratWrappers)
library(kableExtra)
options(future.globals.maxSize = 1e9)
```

# 2. Load Data

## 2-1. Create data table containing sample information

For each sample, we know the phenotype (10 wk CR crypt, 10 wk ACR crypt, 5 wk AKCR crypt, 10 wk AKCR crypt, ACR tumor, AKCR tumor) and the sequencing run, which we can derive from the read header. Let’s create a data table containing this information.

```{r datatable, echo=TRUE, warning=TRUE}
experiment.metadata <- data.frame(id = c("CR_old_crypt_1",
                                         "CR_old_crypt_2",
                                         "ACR_old_crypt_1",
                                         "AKCR_young_crypt",
                                         "AKCR_young_crypt_mT",
                                         "AKCR_young_crypt_eGFP",
                                         "AKCR_old_crypt",
                                         "ACR_tumor",
                                         "AKCR_tumor_eGFP",
                                         "AKCR_tumor"),
                                  phenotype = c("CR crypt",
                                            "CR crypt",
                                            "ACR crypt",
                                            "AKCR crypt",
                                            "AKCR crypt",
                                            "AKCR crypt",
                                            "AKCR crypt",
                                            "Tumor",
                                            "Tumor",
                                            "Tumor"),
                                  batch = c("H5VVWDRX5",
                                          "2277LWLT1",
                                          "H5VVWDRX5",
                                          "2277LWLT1",
                                          "HJ2YLDRX3",
                                          "HJ2YLDRX3",
                                          "2277LWLT1",
                                          "2277LWLT1",
                                          "HJ2YLDRX3",
                                          "2277LWLT1"))
experiment.metadata %>%
  kable() %>%
  kable_styling("striped")
```

## 2-2. Create metrics tables

In this section, the metrics_summary.csv files produced by Cellranger are used to create a single table summarizing the sequencing metrics for each sample.

```{r metricstable, echo=TRUE, warning=TRUE}
dataset.loc <- "/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/Files for analysis in R/"
sample.metrics <- lapply(experiment.metadata$id, function(id) {
  
  # Construct the full path to the metrics file
  # Note: The path might need "/outs/" if your files are in that subdirectory
  metrics_path <- file.path(dataset.loc, id, "metrics_summary.csv")
  
  # Check if the file exists to prevent errors
  if (!file.exists(metrics_path)) {
    warning(paste("Metrics file not found for sample:", id))
    return(NULL) # Skip this file if it doesn't exist
  }
  
  metrics <- read.csv(metrics_path, stringsAsFactors = FALSE)
  
  # Clean and reshape the data
  metrics_wide <- metrics %>%
    select(Metric.Name, Metric.Value) %>%
    # Remove rows where the metric name is blank or missing
    filter(!is.na(Metric.Name) & Metric.Name != "") %>%
    # Keep only the first instance of any duplicate metric
    distinct(Metric.Name, .keep_all = TRUE) %>%
    # Pivot the data from long to a single wide row
    pivot_wider(names_from = Metric.Name, values_from = Metric.Value)
  
  return(metrics_wide)
})

# Combine the list of single-row data frames into one
# Filter out any NULL results from missing files
sample.metrics <- sample.metrics[!sapply(sample.metrics, is.null)]
experiment.metrics <- dplyr::bind_rows(sample.metrics)

# Now, the row count matches the sample count
experiment.metrics$id <- experiment.metadata$id

# Convert the 'id' column into the actual row names
# This creates a clean data frame with proper row names
experiment.metrics <- experiment.metrics %>%
  column_to_rownames(var = "id")

# --- Now, the transpose will work as expected ---
# Using as.data.frame() is often safer than data.frame(t(...))
sequencing.metrics <- as.data.frame(t(experiment.metrics[,c(1:16)]))

# Your final step to clean the metric names (the new row names)
rownames(sequencing.metrics) <- gsub("\\."," ", rownames(sequencing.metrics))

# List every row name from your table in the exact order you want them to appear.
metric_order <- c(
  # Overview Metrics
  "Cells",
  "Mean reads per cell",
  "Median UMI counts per cell",
  "Median genes per cell",
  "Total genes detected",
  "Number of reads from cells called from this sample",
  # Mapping Metrics
  "Confidently mapped reads in cells",
  "Reads confidently mapped to filtered probe set",
  "Reads confidently mapped to probe set"
  # ... add any other metrics in your desired order
)

# 2. Reorder the data frame based on your specified order
# The 'match' function ensures they are sorted correctly.
sequencing.metrics_ordered <- sequencing.metrics[match(metric_order, rownames(sequencing.metrics)), ]


# 3. Now, create the table using the reordered data and simple numeric ranges
sequencing.metrics_ordered %>%
  kable(caption = 'Cell Ranger Results') %>%
  kable_styling("striped") %>%
  # These ranges now correspond to the newly ordered data frame
  pack_rows("Overview", 1, 6, label_row_css = "background-color: #666; color: #fff;") %>%
  pack_rows("Mapping Characteristics", 7, 9, label_row_css = "background-color: #666; color: #fff;")
```

## 2-3. Load 11 10X Genomics scRNAseq data and create Seurat object

A spatial gene expression dataset of mouse distal colon and tumor tissue collected by Space Ranger 2.0.0. will
be analyzed throughout the tutorial. Both the gene expression matrix and spatial imaging data are
necessary for the computational analysis.
The data files we will be using today include:
- a (filtered) feature / cell matrix HDF5 file (.h5)

```{r load10xdata, echo=TRUE, warning=TRUE}
CR_old_crypt_1.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA24099 with 10000 forcecells/per_sample_outs/CR_c2/count/sample_filtered_feature_bc_matrix.h5")
ACR_old_crypt_1.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA24099 with 10000 forcecells/per_sample_outs/ACR_c2/count/sample_filtered_feature_bc_matrix.h5")
CR_old_crypt_2.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA25063 with 10000 forcecells/CR-c_ACR-c_ACR-t/per_sample_outs/CR-c/count/sample_filtered_feature_bc_matrix.h5")
ACR_tumor.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA25063 with 10000 forcecells/CR-c_ACR-c_ACR-t/per_sample_outs/ACR-t/count/sample_filtered_feature_bc_matrix.h5")
AKCR_young_crypt.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA25063 with 10000 forcecells/AKCR-yc_AKCR-c_AKCR-t/per_sample_outs/AKCR-yc/count/sample_filtered_feature_bc_matrix.h5")
AKCR_old_crypt.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA25063 with 10000 forcecells/AKCR-yc_AKCR-c_AKCR-t/per_sample_outs/AKCR-c/count/sample_filtered_feature_bc_matrix.h5")
AKCR_young_crypt_mT.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA23214/setA_per_sample_outs/Flt_AKCR_c_mT/count/sample_filtered_feature_bc_matrix.h5")
AKCR_young_crypt_eGFP.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA23214/setA_per_sample_outs/Flt_AKCR_c_eGFP/count/sample_filtered_feature_bc_matrix.h5")
AKCR_tumor_eGFP.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA23214/setA_per_sample_outs/Flt_AKCR_t_eGFP/count/sample_filtered_feature_bc_matrix.h5")
AKCR_tumor.data <- Read10X_h5("/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/03.cell ranger output/JA25063 with 10000 forcecells/AKCR-yc_AKCR-c_AKCR-t/per_sample_outs/AKCR-t/count/sample_filtered_feature_bc_matrix.h5")

```

```{r createseuratobj, echo=TRUE, warning=TRUE}
CR_old_crypt_1 <- CreateSeuratObject(counts = CR_old_crypt_1.data,
                                      project = "CR_old_crypt_1", 
                                      min.features = 2)
CR_old_crypt_2 <- CreateSeuratObject(counts = CR_old_crypt_2.data,
                                      project = "CR_old_crypt_2",
                                      min.features = 2)
ACR_old_crypt_1 <- CreateSeuratObject(counts = ACR_old_crypt_1.data,
                                       project = "ACR_old_crypt_1", 
                                       min.features = 2)
ACR_tumor <- CreateSeuratObject(counts = ACR_tumor.data, 
                                project = "ACR_tumor",
                                min.features = 2)
AKCR_young_crypt <- CreateSeuratObject(counts = AKCR_young_crypt.data,
                                     project = "AKCR_young_crypt", 
                                     min.features = 2)
AKCR_old_crypt <- CreateSeuratObject(counts = AKCR_old_crypt.data,
                                      project = "AKCR_old_crypt",
                                      min.features = 2)
AKCR_young_crypt_mT <- CreateSeuratObject(counts = AKCR_young_crypt_mT.data,
                                         project = "AKCR_young_crypt_mT",
                                         min.features = 2)
AKCR_young_crypt_eGFP <- CreateSeuratObject(counts = AKCR_young_crypt_eGFP.data,
                                           project = "AKCR_young_crypt_eGFP", 
                                           min.features = 2)
AKCR_tumor_eGFP <- CreateSeuratObject(counts = AKCR_tumor_eGFP.data,
                                      project = "AKCR_tumor_eGFP", 
                                      min.features = 2)
AKCR_tumor <- CreateSeuratObject(counts = AKCR_tumor.data, 
                                 project = "AKCR_tumor",
                                 min.features = 2)
```

```{r viewmetadata, echo=TRUE, warning=TRUE}
head(CR_old_crypt_1@meta.data)
head(CR_old_crypt_2@meta.data)
head(ACR_old_crypt_1@meta.data)
head(ACR_tumor@meta.data)
head(AKCR_old_crypt@meta.data)
head(AKCR_young_crypt@meta.data)
head(AKCR_young_crypt_mT@meta.data)
head(AKCR_young_crypt_eGFP@meta.data)
head(AKCR_tumor_eGFP@meta.data)
head(AKCR_tumor@meta.data)
```

```{r viewdata, echo=TRUE, warning=TRUE}
CR_old_crypt_1
CR_old_crypt_2
ACR_old_crypt_1
ACR_tumor
AKCR_young_crypt
AKCR_old_crypt
AKCR_young_crypt_mT
AKCR_young_crypt_eGFP
AKCR_tumor_eGFP      
AKCR_tumor
rm(list = ls(pattern = "\\.data$"))
```

```{r merge, echo=TRUE, warning=TRUE}
# merge into one single seurat object. Add cell ids just in case you have overlapping barcodes between the datasets.
C19c_raw <- merge(CR_old_crypt_1, 
                  c(CR_old_crypt_2, ACR_old_crypt_1, AKCR_young_crypt_mT, 
                    AKCR_young_crypt_eGFP, AKCR_young_crypt, AKCR_old_crypt,
                    ACR_tumor, AKCR_tumor, AKCR_tumor_eGFP), 
                  add.cell.ids=c("CR_old_crypt_1","CR_old_crypt_2", "ACR_old_crypt_1",
                                 "AKCR_young_crypt_mT", "AKCR_young_crypt_eGFP", "AKCR_young_crypt",
                                 "AKCR_old_crypt", "ACR_tumor", "AKCR_tumor", "AKCR_tumor_eGFP"))
C19c_raw
table(Idents(C19c_raw))
head(C19c_raw@meta.data)
```
## 2-4. Add metadata

The columns of the expression matrix correspond to the cells in the experiment. When we created the Seurat object, the sample information is stored in a variable called “orig.ident.”

```{r viewlevels, echo=TRUE, warning=TRUE}
unique(C19c_raw$orig.ident)
levels(C19c_raw$orig.ident)
```
These sample identifiers are stored in the experiment.metadata object as well, which allows us to match the other metadata contained within that table to the correct cells within the Seurat object.

```{r sampleindex, echo=TRUE, warning=TRUE}
sample.index <- match(C19c_raw$orig.ident, experiment.metadata$id)
```

```{r addmeta, echo=TRUE, warning=TRUE}
C19c_raw <- AddMetaData(C19c_raw,
                                    metadata = experiment.metadata$phenotype[sample.index],
            col.name = "phenotype")
C19c_raw$phenotype <- factor(C19c_raw$phenotype,
                                     levels = c("CR crypt",
                                            "ACR crypt",
                                            "AKCR crypt",
                                            "Tumor"))
C19c_raw <- AddMetaData(C19c_raw,
                                    metadata = experiment.metadata$batch[sample.index],
                                    col.name = "batch")
C19c_raw$batch <- factor(C19c_raw$batch,
                                   levels = c("H5VVWDRX5",
                                          "2277LWLT1",
                                          "HJ2YLDRX3"))
```

## 2-5. Explore the Seurat object

A Seurat object is a complex data structure containing the data from a single cell or single nucleus assay and all of the information associated with the experiment, including annotations, analysis, and more. This data structure was developed by the authors of the Seurat analysis package, for use with their pipeline.

```{r explore1, echo=TRUE, warning=TRUE}
C19c_raw
```

Most Seurat functions take the object as an argument, and return either a new Seurat object or a ggplot object (a visualization). As the analysis continues, more and more data will be added to the object.

```{r explore2, echo=TRUE, warning=TRUE}
slotNames(C19c_raw)
```

```{r explore3, echo=TRUE, warning=TRUE}
C19c_raw@assays # a slot is accessed with the @ symbol
```

```{r explore4, echo=TRUE, warning=TRUE}
# which slot is being accessed here? find another way to produce the result
head(C19c_raw[[]])
```

# 3. Preprocess data

The seed is used to initialize pseudo-random functions. Some of the functions we will be using have pseudo-random elements. Setting a common seed ensures that all of us will get the same results, and that the results will remain stable when re-run.

```{r setseed, echo=TRUE, warning=TRUE}
set.seed(12345)
```

## 3-1. Quality control

A few common QC metrics include

- The number of unique genes detected in each sample (nFeature_RNA).
- The total number of molecules detected within a sample (nCount_RNA).
- The percentage of reads that map to the mitochondrial genome (percent.mt).

We will manually calculate the proportion of mitochondrial reads and add to the metadata table.

```{r percent.mito, echo=TRUE, warning=TRUE}
C19c_raw$percent.mito <- PercentageFeatureSet(object = C19c_raw, pattern = "^mt-")
summary(C19c_raw$percent.mito)
```
## 3-2. Display metadata by quantile

Using a few nested functions, we can produce prettier, more detailed, versions of the simple exploratory summary statistics we generated for the available metadata in the last section. In the code below, 10% quantile tables are produced for each metadata value, separated by sample identity.

```{r mylevels, echo=TRUE, warning=TRUE}
# Check the metadata
my_levels <- c(
    "CR_old_crypt_1",
    "CR_old_crypt_2",
    "ACR_old_crypt_1",
    "AKCR_young_crypt_mT",
    "AKCR_young_crypt_eGFP",
    "AKCR_young_crypt",
    "AKCR_old_crypt",
    "ACR_tumor",
    "AKCR_tumor",
    "AKCR_tumor_eGFP"
)
C19c_raw$orig.ident <- factor(x = C19c_raw$orig.ident, levels = my_levels)
```

```{r quantile.feature, echo=TRUE, warning=TRUE}
kable(do.call("cbind", tapply(C19c_raw$nFeature_RNA,
                              Idents(C19c_raw),
                              quantile, probs = seq(0,1,0.1))),
      caption = "10% Quantiles of Genes/Cell by Sample") %>% kable_styling()
```

```{r quantile.count, echo=TRUE, warning=TRUE}
kable(do.call("cbind", tapply(C19c_raw$nCount_RNA,
                              Idents(C19c_raw),
                              quantile, probs = seq(0,1,0.1))),
      caption = "10% Quantiles of UMI/Cell by Sample") %>% kable_styling()
```

```{r quantile.mito, echo=TRUE, warning=TRUE}
kable(do.call("cbind", tapply(C19c_raw$percent.mito,
                              Idents(C19c_raw),
                              quantile, probs = seq(0,1,0.1))),
      caption = "10% Quantiles of Percent Mitochondrial by Sample") %>% kable_styling()
```

## 3-3.Visualize distribution of metadata values

The `VlnPlot` function produces a composite plot with one panel for each element of the “features” vector. The data are grouped by the provided identity; by default, this is the active identity of the object, which can be accessed using the `Idents()` function, or in the “active.ident” slot.

```{r feature_RNA, echo=TRUE, warning=TRUE}
plot <- VlnPlot(C19c_raw,
        features = c("nFeature_RNA", "nCount_RNA","percent.mito"),
        ncol = 1,
        raster=FALSE,
        pt.size = 0) + theme(legend.position = 'right')
plot 
png(filename = "./Plots/vlnplot_rawdata.png", height = 4000, width = 4000, res = 300)
print(plot)
dev.off()
```

![Violin Plot](../01.preprocessing/Plots/vlnplot_rawdata.png)

### Custom plots

The code below produces a ranked plot similar to the barcode inflection plots from the last section. On the x-axis are the genes arranged from most ubiquitously expressed to rarest. In a single cell dataset, many genes are expessed in a relatively small number of cells, or not at all. The y-axis displays the number of cells in which each gene is expressed.

``{r custom, echo=TRUE, warning=TRUE}
C19c_raw <- JoinLayers(C19c_raw)
# retrieve count data
counts <- GetAssayData(C19c_raw)
# order genes from most to least ubiquitous
ranked.genes <- names(sort(Matrix::rowSums(counts >= 3), decreasing = TRUE))
# drop genes not expressed in any cell
ranked.genes <- ranked.genes[ranked.genes %in% names(which(Matrix::rowSums(counts >= 3) >= 1))]
# get number of cells in which gene is expressed for each sample
cell.counts <- sapply(ranked.genes, function(gene){
  tapply(counts[gene,], C19c_raw$orig.ident, function(x){
    sum(x >= 3)
  })
})
cell.counts <- as.data.frame(t(cell.counts))
cell.counts$gene <- rownames(cell.counts)
cell.counts$rank <- seq(1:dim(cell.counts)[1])
my_plot <- cell.counts %>%
  pivot_longer(cols = 1:3, names_to = "sample", values_to = "count") %>%
  ggplot(mapping = aes(x = rank, y = count, color = sample)) +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log10") +
  geom_point(size=0.2) +
  theme_classic() +
  theme(legend.title = element_blank())

my_plot
ggsave(filename = "./Plots/my_gene_expression_plot.png", plot = my_plot, width = 8, height = 6, dpi = 300)
``
### Scatter plots

Scatter plots allow us to visualize the relationships between the metadata variables.

```{r scatter1, echo=TRUE, warning=TRUE}
# mitochondrial vs UMI
p1 <- FeatureScatter(C19c_raw,
               feature1 = "nCount_RNA",
               feature2 = "percent.mito",
               raster=FALSE,
               shuffle = TRUE) 
p1
png(filename = "./Plots/scatter1.png", height = 2000, width = 4000, res = 300)
print(p1)
dev.off()
```

```{r scatter2, echo=TRUE, warning=TRUE}
# mitochondrial vs genes
p2 <- FeatureScatter(C19c_raw,
               feature1 = "nFeature_RNA",
               feature2 = "percent.mito",
               raster=FALSE,
               shuffle = TRUE) 
p2
png(filename = "./Plots/scatter2.png", height = 4000, width = 4000, res = 300)
print(p2)
dev.off()
```

```{r scatter3, echo=TRUE, warning=TRUE}
# genes vs UMI
p3 <- FeatureScatter(C19c_raw,
               feature1 = "nCount_RNA",
               feature2 = "nFeature_RNA",
               raster=FALSE,
               shuffle = TRUE)  
p3
png(filename = "./Plots/scatter3.png", height = 4000, width = 4000, res = 300)
print(p3)
dev.off()
```

Based on the plots and the 10% quartile, we will exclude 

Because we will be using scDblFinder as a doublet detection tool, we will not be setting the upper limit for QC. The input to scDblFinder should not include empty droplets, and it might be necessary to remove cells with a very low coverage (e.g. <200 or 500 reads) to avoid errors. Further quality filtering should be performed **downstream** of doublet detection, for two reasons: 1. the default expected doublet rate is calculated on the basis of the cells given, and if you excluded a lot of cells as low quality, scDblFinder might think that the doublet rate should be lower than it is. 2. kicking out all low quality cells first might hamper our ability to detect doublets that are formed by the combination of a good quality cell with a low-quality one. This being said, these are mostly theoretical grounds, and unless your QC filtering is very stringent (and it shouldn’t be!), it’s unlikely to make a big difference.

```{r subset, echo=TRUE, warning=TRUE}
C19c_subset <- subset(C19c_raw, subset = nFeature_RNA > 300 
                      & nCount_RNA > 500
                      & percent.mito < 15)
print(paste("Filter out", ncol(C19c_raw) - ncol(C19c_subset), 
            "samples because of the outlier QC metrics, with", ncol(C19c_subset), "samples left."))
```

```{r mylevels2, echo=TRUE, warning=TRUE}
# Check the metadata
my_levels <- c(
    "CR_old_crypt_1",
    "CR_old_crypt_2",
    "ACR_old_crypt_1",
    "AKCR_young_crypt_mT",
    "AKCR_young_crypt_eGFP",
    "AKCR_young_crypt",
    "AKCR_old_crypt",
    "ACR_tumor",
    "AKCR_tumor",
    "AKCR_tumor_eGFP"
)
C19c_subset$orig.ident <- factor(x = C19c_subset$orig.ident, levels = my_levels)

plot2 <- VlnPlot(C19c_subset, group.by = 'orig.ident', 
                  features = c("nFeature_RNA", "nCount_RNA", "percent.mito"),
                  raster = FALSE,ncol = 1, pt.size = 0) + theme(legend.position = 'right')
plot2
png(filename = "./Plots/vlnplot_subsetdata.png", height = 4000, width = 4000, res = 300)
print(plot2)
dev.off()
```

```{r subsetRDS, echo=TRUE, warning=TRUE}
saveRDS(C19c_raw, file = "./C19c_raw.rds")
saveRDS(C19c_subset, file="/stor/work/Fleet/C19_Projects/C19c_10X_scRNA-seq_Project/04.Analysis in R/02.Doublet detection/C19c_subset.rds")
```

```{r sessionInfo, echo=TRUE, warning=TRUE}
sessionInfo()
```

